### **Project Brief: "Eversummer Days" (Working Title) - Revision 4**

**Game Premise:**
*   **Genre:** 2D, Tile-Based, Hybrid Turn-Based Tactical RPG.
*   **Core Philosophy:** A "Fantasy World Simulator" that prioritizes deep, systemic interactivity and emergent gameplay over a linear, scripted narrative. The goal is a highly faithful digital adaptation of the D&D 3.5e OGL ruleset.
*   **Inspiration:** The mechanical depth and rule-based world of **Dungeons & Dragons 3.5e OGL**, the strategic, systems-driven combat of **Incursion**, and the profound emergent interactions and player freedom of **NetHack**.
*   **Setting:** A setting-agnostic fantasy world, intentionally designed as a blank canvas for community-driven content.
*   **Core Gameplay Loop:** Explore dangerous environments, overcome challenges using a wide array of tactical actions and items, engage in turn-based combat governed by a strict ruleset (including flanking and attacks of opportunity), and develop unique characters through a class-based system.

**High-Level Objectives:**
1.  **Build a Systems-First Engine:** The primary goal is to create a robust, bespoke game engine in TypeScript that simulates a fantasy world governed by consistent, interlocking rules. The story and quests are secondary to the quality of the simulation.
2.  **Embrace Emergent Gameplay:** The engine will not script specific outcomes. Instead, it will provide a toolbox of universal actions (`Use`, `Equip`, `Attack`) and a rich set of object properties (tags, materials, curses, magical enchantments). The "gameplay" will emerge from the logical and often surprising interactions between these systems.
3.  **True Plug-and-Play Moddability:** The engine must be a **rules-agnostic interpreter**. Users must be able to add new races, classes, items, spells, and even fundamental game mechanics by simply adding data (`.json`) and logic (`.mjs`) files, without ever recompiling the core engine.
4.  **Flexible Content Generation:** The engine must support both handcrafted, static maps for authored experiences and procedural dungeon generation for infinite replayability, allowing content creators to blend both approaches within a single campaign.

**Key Design Concepts & Technical Requirements:**
*   **Architectural Pillars:**
    *   **Service Locator:** A single, global point of access for all engine systems and the game state, ensuring controlled, explicit dependencies.
    *   **Event Bus:** A central nervous system for decoupled communication, allowing systems to react to game events (like `action:move:provokes_aoo`) without direct knowledge of one another.
    *   **Hybrid Turn System:** A stateful `TurnManager` that seamlessly transitions between real-time "Exploration Mode" and a strict, initiative-based "Combat Mode," correctly handling out-of-turn actions like Attacks of Opportunity.
    *   **Modifier Pipeline:** A sophisticated system (`ModifierManager`, `ModifierList`) for calculating all rolls and statistics by applying `Modifiers` of different types (`racial`, `armor`, `competence`, `untyped`), correctly handling D&D's complex bonus stacking and capping (e.g., Max DEX Bonus) rules.
    *   **Global Tagging System:** A universal metadata system (`tags: string[]`) on all content items and instances to drive rules, validation, and emergent interactions.
*   **Combinatorial Item System:** Items are generated by combining a **base item** (`longsword.json`) with one or more **magic properties** (`flaming.json`, `+1.json`) and **materials** (`adamantine.json`). A `LootFactory` is responsible for this procedural generation, creating immense variety from a small set of data files.
*   **Modular AI with Behavioral Flags:** AI is not monolithic. A single, powerful AI Package acts as a "behavior runner." Monster prefabs specify a list of behavioral flags (`ai_flags: ["FLEER", "ARCHER"]`) that dictate which reusable AI subroutines the runner should execute, allowing for complex AI composition through data.
*   **Unified Entity Model:** All characters (PCs and NPCs) are built from the same fundamental `Entity` class and share the same components (`InventoryComponent`, `EquipmentComponent`), ensuring rules consistency.
*   **Rendering:** An initial ASCII/character-based rendering on HTML5 Canvas, driven by a `Renderable` component for maximum flexibility and decoupling.

---

### **Implementation Checklist: The Path to MVP and Beyond (Revision 6)**

#### **Phase 0: Architecture Complete**
*   `[x]` **Implement the Global Tagging System.**
*   `[x]` **Build the Core `RulesEngine` Service.**
*   `[x]` **Implement the Service Locator Pattern.**
*   `[x]` **Decouple and Refactor the UI.**
*   `[x]` **Implement the `Renderable` Component.**
*   `[x]` **Unify NPCs with an `NpcFactory`.**
*   `[x]` **Build the `TurnManager`.**
*   `[x]` **Implement Full Feat & Ability Application.**
*   `[x]` **Formalize the Action Economy.**
*   `[x]` **Task 0.1: Centralize Internal Engine Event Strings.**
    *   **Status:** Done. Created `src/scripts/engine/events.mts` and refactored all engine and UI code to use the new `GameEvents` constants instead of raw strings.

---
#### **Phase 1: Character & Action Systems Online**
*   `[x]` **Action Economy Framework Established.**
*   `[x]` **Feat & Ability Application Implemented.**
*   `[x]` **"Attack" Action Chain Implemented.**
*   `[x]` **Full Damage Calculation Implemented.**
*   `[x]` **Critical Hits Implemented.**
*   `[x]` **Modular AI Execution Implemented (Initial Refactor).**
*   `[x]` **Movement Point System Implemented.**
    *   **Status:** Done. The `TurnManager` now grants movement points, and the `RulesEngine` deducts them based on tile cost.

---
#### **Phase 2: Deep Equipment & Itemization (Revised)**
*   `[x]` **Task 2.1: Implement the Full Equipment System.**
*   `[x]` **Task 2.2: Implement Combinatorial Item Generation (`LootFactory`).**
*   `[ ]` **Task 2.3: Implement the "Use Item" Action.**
    *   `[ ]` **Sub-task 2.3.1:** Define "Use Item" as a Standard Action by default (e.g., drinking a potion, reading a scroll).
    *   `[ ]` **Sub-task 2.3.2:** Implement logic for item uses that provoke Attacks of Opportunity (AoOs), such as drinking a potion or applying an oil.
    *   `[ ]` **Sub-task 2.3.3:** Differentiate activation types (Spell Completion, Command Word, Use-Activated) and ensure they do not provoke AoOs unless specified.
*   `[ ]` **Task 2.4: Implement Item Identification.**
*   `[ ]` **Task 2.5: Implement Item States via Tags.** (e.g., `[state:cursed]`, `[state:identified]`, `[state:broken]`)

---
#### **Phase 3: Advanced Combat Tactics (Revised)**
*   `[ ]` **Task 3.1: Implement Attacks of Opportunity (AoO) System.**
    *   `[ ]` **Sub-task 3.1.1:** Implement the core AoO trigger: leaving a threatened square.
    *   `[ ]` **Sub-task 3.1.2:** Implement AoO triggers for combat actions (e.g., making a Ranged Attack while threatened, Unarmed Strikes without the `Improved Unarmed Strike` feat).
    *   `[ ]` **Sub-task 3.1.3:** Implement AoO triggers for general actions (e.g., Casting a Spell, Drinking a Potion, Standing Up from Prone).
    *   `[ ]` **Sub-task 3.1.4:** Ensure AoOs are a specific type of Free Action that does not consume the attacker's normal actions but is limited to one per opportunity.
*   `[x]` **Task 3.2: Implement Terrain Movement Costs.**
*   `[ ]` **Task 3.3: Implement Special Combat Actions.**
    *   `[ ]` **Sub-task 3.3.1:** Implement **Charge** (Full-Round Action).
    *   `[ ]` **Sub-task 3.3.2:** Implement **Trip** (replaces a normal melee attack).
    *   `[ ]` **Sub-task 3.3.3:** Implement **Disarm** (replaces a normal melee attack).
    *   `[ ]` **Sub-task 3.3.4:** Implement **Bull Rush** (Standard Action).
    *   `[ ]` **Sub-task 3.3.5:** Implement **Feint** (Standard Action in combat).
    *   `[ ]` **Sub-task 3.3.6:** Implement **Grapple** (replaces an attack, with special follow-up rules).
*   `[ ]` **Task 3.4: Implement Tactical Actions.**
    *   `[ ]` **Sub-task 3.4.1:** Implement **Aid Another** to help allies with attacks or skills.
    *   `[ ]` **Sub-task 3.4.2:** Implement the **Ready** action (to prepare a Standard Action).
    *   `[ ]` **Sub-task 3.4.3:** Implement the **Total Defense** action (+4 dodge bonus to AC).
    *   `[ ]` **Sub-task 3.4.4:** Implement the **Withdraw** action (Full-Round Action to safely move out of melee).

---
#### **Phase 4: Advanced World Systems (Revised)**
*   `[ ]` **Task 4.1: Implement Modular AI with Behavioral Flags.**
*   `[ ]` **Task 4.2: Implement the Unified Spellbook & Casting System.**
    *   `[ ]` **Sub-task 4.2.1:** Implement **Concentration** checks when taking damage or being affected by distractions while casting.
    *   `[ ]` **Sub-task 4.2.2:** Implement the **"Cast on the Defensive"** option (requires a Concentration check to avoid provoking an AoO).
    *   `[ ]` **Sub-task 4.2.3:** Implement **Touch Spells**, including Melee/Ranged Touch Attacks and the ability to "Hold the Charge".
    *   `[ ]` **Sub-task 4.2.4:** Differentiate spell casting times (Standard Action, Full-Round, Free Action for quickened spells) and their impact on the combat round.
*   `[ ]` **Task 4.3: Implement Advanced Procedural Generation.**
*   `[ ]` **Task 4.4: Implement Saving and Loading.**

---
#### **Phase 5: Systemic Interactions (The NetHack Factor)**
*   `[ ]` **Task 5.1: Implement Material Interactions.**
    *   **Guidance:** Use the event bus and tagging system. Create a listener that checks for `action:damage:resolved`. If a weapon with the `[slashing]` tag hits a creature with the `[material:wood]` tag, the creature takes extra damage. If a monster attack with `[acid]` hits a player wearing armor with the `[material:iron]` tag, the armor's `armor_bonus` modifier should be permanently reduced.
*   `[ ]` **Task 5.2: Implement Environmental Interactions.**
    *   **Guidance:** A `fire` spell hitting a `[flammable]` tile (e.g., "dry grass") should change the tile type to "burning grass" and apply damage to any creature standing on it at the end of their turn.
*   `[ ]` **Task 5.3: Implement Item-on-Item Interactions.**
    *   **Guidance:** Refactor the `UseItemAction` to optionally take a second target (`targetItem`). This would allow for actions like `Use(player, potion_of_healing, sword)`, which could apply a temporary poison to the weapon. This is the foundation for NetHack's "dipping" mechanic.


---
### Online references for D&D 3.5e : 
*   https://www.d20srd.org/index.htm
*   https://www.realmshelps.net
*   https://srd.dndtools.org/
*   http://dndsrd.net/
*   https://dndtools.net
*   https://dnd.arkalseif.info

### Incursion d20 references and source code : 
*   https://www.roguebasin.com/index.php/Incursion
*   https://github.com/rmtew/incursion-roguelike

### NetHack references and source code : 
*   https://nethackwiki.com
*   https://github.com/NetHack/NetHack
